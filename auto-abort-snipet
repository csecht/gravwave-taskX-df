#!/bin/bash
boinc_cmd=$(command -v boinccmd)

. ./taskXDF.cfg
#ttime_max=2
interval_time=60
#auto_abort=yes


# Need to be sure the file is there.
touch ./currently_running_GWtasks.txt
gravtask_file="./currently_running_GWtasks.txt"

simple_gui_info="$( ${boinc_cmd} --get_simple_gui_info )"  # NOTE: includes uploading and waiting tasks.

# Need to gather ALL active task names-active state pairs then save to file only names of Executing O2MDF tasks.
# Need to skip over lines that have the '   name: ' tag until get to the ======== Tasks ======== section.
# A task name will always be before its active state. Need to avoid the tag 'WU name: ', hence '^name'.
active_data=""
task_section=no
while read -r line; do
    if [[ ! $line =~ '= Tasks =' ]]  && [[ $task_section == no ]]; then
        continue
    elif [[ $line =~ '= Tasks =' ]]; then
        task_section=yes
    elif [[ $task_section == yes ]] && [[ $line =~ ^name ]]; then
        active_data="${active_data}"$'\n'"$line" # First pass prepends a newline.
    elif [[ $task_section == yes ]] && [[ $line =~ active_task_state: ]]; then
        active_data="${active_data}"$'\n'"$line"
    fi
done <<<"$simple_gui_info"

# Save only GW (O2MDF) task names that are currently running (EXECUTING).
gravtask_line=""
while read -r line; do
    if [[ $line =~ O2MDF ]]; then
        gravtask_line=$line
        continue
    fi
    # Need to determine whether paired active_task_state line following name line specifies a running task.
    if [[ $gravtask_line =~ O2MDF ]] && [[ $line =~ EXECUTING ]]; then
        gravtask_name=$(sed 's/name: //' <<<"$gravtask_line")
        echo "$gravtask_name" >>"$gravtask_file"
        running_names="${running_names}"$'\n'"$gravtask_name" # First pass prepends a newline.
    fi
done <<<"$active_data"
sleep 0.5

# $interval_time is passed as seconds from taskXDF-timer when timer script first starts
# $ttime_max is passed as minutes from taskXDF.cfg.
interval_minute=$((interval_time / 60))
max_runningtask_count=$((ttime_max / interval_minute))

# Need to set initial value of all tasks being new, then prove otherwise.
all_tasks_new=yes
# Need to evaluate only when there are running (EXECUTING) tasks.
# Abort only 1 task per script cycle, hence 'break'
if [[ $running_names ]]; then
    while read -r name; do
        [[ -z $name ]] && continue # Skip blank lines that will mess things up here.
        runningtask_reps=$(grep -c $name $gravtask_file)
        echo "task: $name, reps: $runningtask_reps, interval min:$interval_minute, max count:$max_runningtask_count"
        if ((runningtask_reps > max_runningtask_count)); then
            echo "$(date "+%b %d %T") NOTICE! Task $name"              | tee -a $log_file
            echo "    is taking more than $ttime_max min to complete " | tee -a $log_file
            if [[ $auto_abort == yes ]]; then
                echo "    IT WILL BE ABORTED."                         | tee -a $log_file
#                ${boinc_cmd} --task http://einstein.phys.uwm.edu/ ${name} abort
                #notice_tone3
                break
            elif [[ $auto_abort == no ]]; then
                echo "    It may need to be aborted."                  | tee -a $log_file
                #notice_tone1
            fi
        fi
        #   Need to flag if any one task is still running since previous script cycle.
        if ((runningtask_reps > 1)); then
            all_tasks_new=no
        fi
    done <<<"$running_names"

    # Need to reset $gravtask_file file with current running_names if current batch of running tasks are all new.
    #   As long as any one task is still running since last script cycle, then file is not reset.
    if [[ $all_tasks_new == yes ]] && [[ -s $gravtask_file ]]; then
        echo "" >"$gravtask_file"
        echo "$running_names" >"$gravtask_file"
    fi
fi
