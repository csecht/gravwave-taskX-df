#!/bin/bash
boinc_cmd=$(command -v boinccmd)

. ./taskXDF.cfg
ttime_max=2
interval_time=60
auto_abort=yes


# Need to be sure the file is there.
touch ./currently_running_GWtasks.txt
gravtask_file="./currently_running_GWtasks.txt"

simple_gui_info="$( ${boinc_cmd} --get_simple_gui_info )"  # NOTE: includes uploading and waiting tasks.

# A task name will always be read before its active state. Need to avoid the tag 'WU name: ', hence '^name'.
# Save only GW (O2MDF) task names that are currently running (EXECUTING).
gravtask_line=""
gravtask_name=""
while read -r line; do
    if [[ $line =~ ^name.*O2MDF ]]; then
        gravtask_line=$line
        continue
    fi
    # Need to determine whether paired active_task_state line following name line specifies that it is a running task.
    if [[ $gravtask_line =~ O2MDF ]] && [[ $line =~ EXECUTING ]]; then
        gravtask_name=$(sed 's/name: //' <<<"$gravtask_line")
        echo "$gravtask_name" >>"$gravtask_file"
        running_names="${running_names}"$'\n'"$gravtask_name" # First pass prepends a newline.
        # Need to clear tasks to keep pair only GW tasks with their active state.
        gravtask_line=""
        gravtask_name=""
    fi
done <<<"$simple_gui_info"
sleep 0.5

# $interval_time is passed as seconds from taskXDF-timer when timer script first starts
# $ttime_max is passed as minutes from taskXDF.cfg.
interval_minute=$((interval_time / 60))
max_runningtask_count=$((ttime_max / interval_minute))

# Need to set initial value of all tasks being new, then prove otherwise.
all_tasks_new=yes
# Need to evaluate only when there are running (EXECUTING) tasks.
# Abort only 1 task per script cycle, hence 'break'
if [[ $running_names ]]; then
    while read -r name; do
        [[ -z $name ]] && continue # Skip blank lines that will mess things up here.
        runningtask_reps=$(grep -c $name $gravtask_file)
        if ((runningtask_reps > max_runningtask_count)); then
            echo "$(date "+%b %d %T") NOTICE! Task $name"              | tee -a $log_file
            echo "    is taking more than $ttime_max min to complete " | tee -a $log_file
            if [[ $auto_abort == yes ]]; then
#                echo "    IT WILL BE ABORTED."                         | tee -a $log_file
                echo "    IT WILL BE temporarily SUSPENDED."           | tee -a $log_file
#                ${boinc_cmd} --task http://einstein.phys.uwm.edu/ ${name} abort
                ${boinc_cmd} --task http://einstein.phys.uwm.edu/ ${name} suspend
                sleep 10
                ${boinc_cmd} --task http://einstein.phys.uwm.edu/ ${name} resume
                notice_tone3
                break
            elif [[ $auto_abort == no ]]; then
                echo "    It may need to be suspended or perhaps aborted." | tee -a $log_file
                notice_tone1
            fi
        fi
        #   Need to flag if any one task is still running since previous script cycle.
        if ((runningtask_reps > 1)); then
            all_tasks_new=no
        fi
    done <<<"$running_names"

    # Need to reset $gravtask_file file with current running_names if current batch of running tasks are all new.
    #   As long as any one task is still running since last script cycle, then file is not reset.
    if [[ $all_tasks_new == yes ]] && [[ -s $gravtask_file ]]; then
        echo "" >"$gravtask_file"
        echo "$running_names" >"$gravtask_file"
    fi
fi

